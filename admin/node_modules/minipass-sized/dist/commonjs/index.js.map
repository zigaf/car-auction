{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Minipass } from 'minipass'\n\nconst isBufferEncoding = (enc: unknown): enc is BufferEncoding =>\n  typeof enc === 'string'\n\nexport class SizeError extends Error {\n  expect: number\n  found: number\n  code: 'EBADSIZE' = 'EBADSIZE'\n  constructor(found: number, expect: number, from?: (...a: any[]) => any) {\n    super(`Bad data size: expected ${expect} bytes, but got ${found}`)\n    this.expect = expect\n    this.found = found\n    Error.captureStackTrace(this, from ?? this.constructor)\n  }\n  get name() {\n    return 'SizeError'\n  }\n}\n\nexport type Options<T extends Minipass.BufferOrString> =\n  Minipass.Options<T> & {\n    objectMode?: false\n    size: number\n  }\n\nexport class MinipassSized<\n  RType extends Minipass.BufferOrString,\n  WType extends Minipass.BufferOrString,\n  Events extends Minipass.Events<RType> = Minipass.Events<RType>,\n> extends Minipass<RType, WType, Events> {\n  found: number = 0\n  expect: number\n\n  constructor(options: Options<RType>) {\n    const size = options?.size\n    if (\n      typeof size !== 'number' ||\n      size > Number.MAX_SAFE_INTEGER ||\n      isNaN(size) ||\n      size < 0 ||\n      !isFinite(size) ||\n      size !== Math.floor(size)\n    ) {\n      throw new Error('invalid expected size: ' + size)\n    }\n\n    //@ts-ignore\n    super(options)\n\n    if (options.objectMode) {\n      throw new TypeError(\n        `${\n          this.constructor.name\n        } streams only work with string and buffer data`,\n      )\n    }\n\n    this.expect = size\n  }\n\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void,\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void,\n  ): boolean {\n    const buffer =\n      Buffer.isBuffer(chunk) ? chunk\n      : typeof chunk === 'string' ?\n        Buffer.from(chunk, isBufferEncoding(encoding) ? encoding : 'utf8')\n      : chunk\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      this.emit(\n        'error',\n        new TypeError(\n          `${\n            this.constructor.name\n          } streams only work with string and buffer data`,\n        ),\n      )\n      return false\n    }\n\n    this.found += buffer.length\n    if (this.found > this.expect)\n      this.emit('error', new SizeError(this.found, this.expect))\n\n    return super.write(chunk, encoding, cb)\n  }\n\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    if (ev === 'end') {\n      if (this.found !== this.expect) {\n        this.emit(\n          'error',\n          new SizeError(this.found, this.expect, this.emit),\n        )\n      }\n    }\n    return super.emit(ev, ...args)\n  }\n}\n"]}